import numpy as np
import os
import pandas as pd
import matplotlib.pyplot as plt
import csv
from scipy import stats, linalg
from mpl_toolkits.mplot3d import Axes3D


def read_coordinates_from_path(path, filenames=None, delimiter=None):
    """
    Считывает координаты частиц из файлов в указанной папке.
    """
    if filenames is None:
        filenames = ['X1000.txt', 'Y1000.txt', 'Z1000.txt']

    try:
        if not os.path.exists(path):
            raise FileNotFoundError(f"Папка {path} не существует")

        filepaths = [os.path.join(path, fname) for fname in filenames]

        print(f"Чтение файлов из папки: {path}")

        for fpath, fname in zip(filepaths, filenames):
            if not os.path.exists(fpath):
                raise FileNotFoundError(f"Файл {fname} не найден в папке {path}")

        if delimiter:
            x_data = np.loadtxt(filepaths[0], delimiter=delimiter)
            y_data = np.loadtxt(filepaths[1], delimiter=delimiter)
            z_data = np.loadtxt(filepaths[2], delimiter=delimiter)
        else:
            x_data = np.loadtxt(filepaths[0])
            y_data = np.loadtxt(filepaths[1])
            z_data = np.loadtxt(filepaths[2])

        print(f"\nРазмеры файлов:")
        print(f"  {filenames[0]}: {x_data.shape} (временные шаги={x_data.shape[0]}, частицы={x_data.shape[1]})")
        print(f"  {filenames[1]}: {y_data.shape}")
        print(f"  {filenames[2]}: {z_data.shape}")

        if not (x_data.shape == y_data.shape == z_data.shape):
            print("\nПредупреждение: Размеры файлов не совпадают!")
            min_rows = min(x_data.shape[0], y_data.shape[0], z_data.shape[0])
            min_cols = min(x_data.shape[1], y_data.shape[1], z_data.shape[1])

            x_data = x_data[:min_rows, :min_cols]
            y_data = y_data[:min_rows, :min_cols]
            z_data = z_data[:min_rows, :min_cols]
            print(f"Используется общий размер: {x_data.shape}")

        coordinates_3d = np.zeros((x_data.shape[0], x_data.shape[1], 3))
        coordinates_3d[:, :, 0] = x_data
        coordinates_3d[:, :, 1] = y_data
        coordinates_3d[:, :, 2] = z_data

        print(f"\nСоздан 3D массив координат: {coordinates_3d.shape}")
        print(f"  Временных шагов: {coordinates_3d.shape[0]}")
        print(f"  Частиц: {coordinates_3d.shape[1]}")

        return x_data, y_data, z_data, coordinates_3d

    except Exception as e:
        print(f"Ошибка: {e}")
        return None, None, None, None


def calculate_median_deviations(coordinates_3d):
    """
    Рассчитывает для каждой частицы медианное положение, отклонения от него,
    максимальное и среднее отклонение.
    """
    if coordinates_3d is None:
        print("Ошибка: Нет данных для расчета")
        return None

    print("\n" + "=" * 60)
    print("РАСЧЕТ МЕДИАННЫХ ПОЛОЖЕНИЙ И ОТКЛОНЕНИЙ")
    print("=" * 60)

    n_particles = coordinates_3d.shape[1]
    n_timesteps = coordinates_3d.shape[0]

    # 1. Рассчитываем медианное положение для каждой частицы
    print(f"Расчет медианных положений для {n_particles} частиц...")

    median_positions = np.median(coordinates_3d, axis=0)  # Форма: [частицы, 3]

    # 2. Рассчитываем отклонения от медианного положения
    print(f"Расчет отклонений для {n_timesteps} временных шагов...")

    deviations = np.zeros_like(coordinates_3d)

    for particle_idx in range(n_particles):
        deviations[:, particle_idx, :] = coordinates_3d[:, particle_idx, :] - median_positions[particle_idx, :]

    # 3. Рассчитываем расстояния (евклидовы нормы) отклонений
    print(f"Расчет расстояний отклонений...")

    deviation_distances = np.linalg.norm(deviations, axis=2)  # Форма: [время, частицы]

    # 4. Рассчитываем статистики для каждой частицы
    max_deviations = np.max(deviation_distances, axis=0)
    mean_deviations = np.mean(deviation_distances, axis=0)

    # Для каждой координаты отдельно
    max_x_deviations = np.max(np.abs(deviations[:, :, 0]), axis=0)
    max_y_deviations = np.max(np.abs(deviations[:, :, 1]), axis=0)
    max_z_deviations = np.max(np.abs(deviations[:, :, 2]), axis=0)

    mean_x_deviations = np.mean(np.abs(deviations[:, :, 0]), axis=0)
    mean_y_deviations = np.mean(np.abs(deviations[:, :, 1]), axis=0)
    mean_z_deviations = np.mean(np.abs(deviations[:, :, 2]), axis=0)

    # Собираем все результаты
    results = {
        'median_positions': median_positions,
        'deviations': deviations,
        'deviation_distances': deviation_distances,
        'max_deviations': max_deviations,
        'mean_deviations': mean_deviations,
        'max_x_deviations': max_x_deviations,
        'max_y_deviations': max_y_deviations,
        'max_z_deviations': max_z_deviations,
        'mean_x_deviations': mean_x_deviations,
        'mean_y_deviations': mean_y_deviations,
        'mean_z_deviations': mean_z_deviations,
        'particle_indices': np.arange(n_particles),
        'coordinates_3d': coordinates_3d
    }

    return results


def calculate_axis_line(median_positions):
    """
    Рассчитывает ось структуры - аппроксимационную прямую для медианных положений частиц.
    """
    print("\n" + "=" * 60)
    print("РАСЧЕТ ОСИ СТРУКТУРЫ")
    print("=" * 60)

    n_particles = median_positions.shape[0]

    # 1. Вычисляем главные компоненты (PCA) для нахождения направления оси
    centroid = np.mean(median_positions, axis=0)
    centered_data = median_positions - centroid

    # Вычисляем ковариационную матрицу
    cov_matrix = np.cov(centered_data.T)

    # Находим собственные значения и собственные векторы
    eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)

    # Направление оси - собственный вектор, соответствующий наибольшему собственному значению
    max_eigenvalue_idx = np.argmax(eigenvalues)
    direction = eigenvectors[:, max_eigenvalue_idx]

    # Нормализуем направляющий вектор
    direction = direction / np.linalg.norm(direction)

    # 2. Линейная регрессия для получения параметров прямой
    t_values = np.dot(centered_data, direction)

    # 3. Вычисляем расстояние от каждой точки до прямой
    distances = []
    for point in median_positions:
        v = point - centroid
        projection = np.dot(v, direction) * direction
        perpendicular = v - projection
        distance = np.linalg.norm(perpendicular)
        distances.append(distance)

    distances = np.array(distances)

    # 4. Коэффициент детерминации R²
    total_variance = np.var(median_positions, axis=0).sum()
    explained_variance = eigenvalues[max_eigenvalue_idx]
    r_squared = explained_variance / total_variance if total_variance > 0 else 0

    # 5. Формируем уравнение прямой
    equation_parametric = f"x = {centroid[0]:.6f} + {direction[0]:.6f} * t\n" \
                          f"y = {centroid[1]:.6f} + {direction[1]:.6f} * t\n" \
                          f"z = {centroid[2]:.6f} + {direction[2]:.6f} * t"

    equation_symmetric = f"(x - {centroid[0]:.6f}) / {direction[0]:.6f} = " \
                         f"(y - {centroid[1]:.6f}) / {direction[1]:.6f} = " \
                         f"(z - {centroid[2]:.6f}) / {direction[2]:.6f}"

    # 6. Строим точки на прямой для визуализации
    t_min = np.min(t_values)
    t_max = np.max(t_values)

    t_range_extended = np.linspace(t_min - 0.2 * (t_max - t_min),
                                   t_max + 0.2 * (t_max - t_min), 100)

    line_points = np.array([centroid + t * direction for t in t_range_extended])

    axis_results = {
        'centroid': centroid,
        'direction': direction,
        'eigenvalues': eigenvalues,
        'eigenvectors': eigenvectors,
        't_values': t_values,
        'distances_to_axis': distances,
        'r_squared': r_squared,
        'equation_parametric': equation_parametric,
        'equation_symmetric': equation_symmetric,
        'line_points': line_points,
        'mean_distance': np.mean(distances),
        'max_distance': np.max(distances),
        'median_distance': np.median(distances),
        'std_distance': np.std(distances)
    }

    # Вывод результатов
    print(f"Центр масс: {centroid}")
    print(f"Направляющий вектор: {direction}")
    print(f"\nУравнение прямой:")
    print(equation_parametric)
    print(f"\nКоэффициент детерминации R²: {r_squared:.6f}")
    print(f"Среднее расстояние до оси: {np.mean(distances):.6f}")
    print(f"Максимальное расстояние до оси: {np.max(distances):.6f}")
    print(f"Медианное расстояние до оси: {np.median(distances):.6f}")
    print(f"Стандартное отклонение расстояний: {np.std(distances):.6f}")

    return axis_results


def calculate_deviations_from_axis(coordinates_3d, axis_results):
    """
    Рассчитывает отклонения частиц от оси структуры во времени.
    Возвращает средние и максимальные отклонения от оси для каждой частицы.
    """
    print("\n" + "=" * 60)
    print("РАСЧЕТ ОТКЛОНЕНИЙ ЧАСТИЦ ОТ ОСИ ВО ВРЕМЕНИ")
    print("=" * 60)

    n_timesteps = coordinates_3d.shape[0]
    n_particles = coordinates_3d.shape[1]

    centroid = axis_results['centroid']
    direction = axis_results['direction']

    print(f"Расчет отклонений для {n_particles} частиц по {n_timesteps} временным шагам...")

    # Массивы для хранения отклонений от оси
    axis_deviations = np.zeros((n_timesteps, n_particles))  # Расстояния до оси
    axis_deviations_x = np.zeros((n_timesteps, n_particles))  # Отклонения по X
    axis_deviations_y = np.zeros((n_timesteps, n_particles))  # Отклонения по Y
    axis_deviations_z = np.zeros((n_timesteps, n_particles))  # Отклонения по Z

    # Проекции на ось
    axis_projections = np.zeros((n_timesteps, n_particles))  # Параметр t

    # Для каждого временного шага и каждой частицы
    for t in range(n_timesteps):
        for p in range(n_particles):
            point = coordinates_3d[t, p, :]

            # Вектор от центра масс до точки
            v = point - centroid

            # Проекция на направление оси (параметр t)
            t_param = np.dot(v, direction)
            axis_projections[t, p] = t_param

            # Проекция точки на ось
            projected_point = centroid + t_param * direction

            # Вектор отклонения от оси
            deviation_vector = point - projected_point

            # Сохраняем компоненты отклонения
            axis_deviations_x[t, p] = deviation_vector[0]
            axis_deviations_y[t, p] = deviation_vector[1]
            axis_deviations_z[t, p] = deviation_vector[2]

            # Евклидово расстояние до оси
            axis_deviations[t, p] = np.linalg.norm(deviation_vector)

    # Рассчитываем статистики для каждой частицы
    max_axis_deviations = np.max(axis_deviations, axis=0)  # Максимальные отклонения
    mean_axis_deviations = np.mean(axis_deviations, axis=0)  # Средние отклонения
    std_axis_deviations = np.std(axis_deviations, axis=0)  # Стандартные отклонения

    # Максимальные отклонения по осям
    max_axis_x = np.max(np.abs(axis_deviations_x), axis=0)
    max_axis_y = np.max(np.abs(axis_deviations_y), axis=0)
    max_axis_z = np.max(np.abs(axis_deviations_z), axis=0)

    # Средние отклонения по осям
    mean_axis_x = np.mean(np.abs(axis_deviations_x), axis=0)
    mean_axis_y = np.mean(np.abs(axis_deviations_y), axis=0)
    mean_axis_z = np.mean(np.abs(axis_deviations_z), axis=0)

    # Статистика проекций на ось
    mean_projections = np.mean(axis_projections, axis=0)
    std_projections = np.std(axis_projections, axis=0)

    # Собираем результаты
    axis_deviations_results = {
        'axis_deviations': axis_deviations,  # Все отклонения [время, частицы]
        'axis_deviations_x': axis_deviations_x,
        'axis_deviations_y': axis_deviations_y,
        'axis_deviations_z': axis_deviations_z,
        'axis_projections': axis_projections,
        'max_axis_deviations': max_axis_deviations,  # Макс. отклонения для каждой частицы
        'mean_axis_deviations': mean_axis_deviations,  # Средние отклонения для каждой частицы
        'std_axis_deviations': std_axis_deviations,
        'max_axis_x': max_axis_x,
        'max_axis_y': max_axis_y,
        'max_axis_z': max_axis_z,
        'mean_axis_x': mean_axis_x,
        'mean_axis_y': mean_axis_y,
        'mean_axis_z': mean_axis_z,
        'mean_projections': mean_projections,
        'std_projections': std_projections
    }

    # Вывод статистики
    print(f"\nСТАТИСТИКА ОТКЛОНЕНИЙ ОТ ОСИ:")
    print(f"Среднее максимальное отклонение от оси: {np.mean(max_axis_deviations):.6f}")
    print(f"Максимальное отклонение от оси: {np.max(max_axis_deviations):.6f}")
    print(f"Среднее среднее отклонение от оси: {np.mean(mean_axis_deviations):.6f}")
    print(f"\nОтклонения по осям (средние максимальные):")
    print(f"  По X: {np.mean(max_axis_x):.6f}")
    print(f"  По Y: {np.mean(max_axis_y):.6f}")
    print(f"  По Z: {np.mean(max_axis_z):.6f}")

    return axis_deviations_results


def save_axis_deviations_to_csv(results, axis_results, axis_deviations_results,
                                output_path, filename="axis_deviations.csv"):
    """
    Сохраняет отклонения частиц от оси в отдельный CSV файл.
    """
    if results is None or axis_results is None or axis_deviations_results is None:
        print("Нет данных для сохранения отклонений от оси")
        return None

    try:
        print(f"\n" + "=" * 60)
        print(f"СОХРАНЕНИЕ ОТКЛОНЕНИЙ ОТ ОСИ В CSV ФАЙЛ")
        print("=" * 60)

        n_particles = len(results['particle_indices'])

        # Создаем полный путь
        full_path = os.path.join(output_path, filename)

        # Открываем файл с правильными параметрами
        with open(full_path, 'w', newline='', encoding='utf-8-sig') as f:
            writer = csv.writer(f)

            # Заголовок файла
            writer.writerow(["ОТКЛОНЕНИЯ ЧАСТИЦ ОТ ОСИ СТРУКТУРЫ"])
            writer.writerow([f"Дата анализа: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}"])
            writer.writerow([f"Количество частиц: {n_particles}"])
            writer.writerow([f"Количество временных шагов: {results['coordinates_3d'].shape[0]}"])
            writer.writerow([])  # Пустая строка

            # Раздел: Информация об оси
            writer.writerow(["ПАРАМЕТРЫ ОСИ СТРУКТУРЫ"])
            writer.writerow(["Параметр", "Значение", "Описание"])
            writer.writerow(["Центр масс (x,y,z)",
                             f"{axis_results['centroid'][0]:.6f}, {axis_results['centroid'][1]:.6f}, {axis_results['centroid'][2]:.6f}",
                             "Точка на оси"])
            writer.writerow(["Направляющий вектор (a,b,c)",
                             f"{axis_results['direction'][0]:.6f}, {axis_results['direction'][1]:.6f}, {axis_results['direction'][2]:.6f}",
                             "Направление оси"])
            writer.writerow(["Коэффициент детерминации R²",
                             f"{axis_results['r_squared']:.6f}",
                             "Качество аппроксимации (0-1)"])
            writer.writerow(["Уравнение оси",
                             axis_results['equation_parametric'].replace('\n', '; '),
                             "Параметрическая форма"])
            writer.writerow([])  # Пустая строка

            # Раздел: Общая статистика отклонений от оси
            writer.writerow(["ОБЩАЯ СТАТИСТИКА ОТКЛОНЕНИЙ ОТ ОСИ"])
            writer.writerow(["Параметр", "Значение", "Примечание"])

            max_deviations = axis_deviations_results['max_axis_deviations']
            mean_deviations = axis_deviations_results['mean_axis_deviations']

            writer.writerow(["Среднее максимальное отклонение",
                             f"{np.mean(max_deviations):.6f}",
                             "По всем частицам"])
            writer.writerow(["Максимальное отклонение",
                             f"{np.max(max_deviations):.6f}",
                             "Наибольшее значение"])
            writer.writerow(["Минимальное максимальное отклонение",
                             f"{np.min(max_deviations):.6f}",
                             "Наименьшее максимальное отклонение"])
            writer.writerow(["Среднее среднее отклонение",
                             f"{np.mean(mean_deviations):.6f}",
                             "По всем частицам"])
            writer.writerow(["Стандартное отклонение макс. отклонений",
                             f"{np.std(max_deviations):.6f}",
                             "Разброс максимальных отклонений"])
            writer.writerow([])  # Пустая строка

            # Раздел: Статистика по осям координат
            writer.writerow(["СТАТИСТИКА ОТКЛОНЕНИЙ ПО ОСЯМ КООРДИНАТ"])
            writer.writerow(["Ось", "Ср. макс. отклонение", "Ср. отклонение", "Относительный вклад (%)"])

            max_x_mean = np.mean(axis_deviations_results['max_axis_x'])
            max_y_mean = np.mean(axis_deviations_results['max_axis_y'])
            max_z_mean = np.mean(axis_deviations_results['max_axis_z'])

            mean_x_mean = np.mean(axis_deviations_results['mean_axis_x'])
            mean_y_mean = np.mean(axis_deviations_results['mean_axis_y'])
            mean_z_mean = np.mean(axis_deviations_results['mean_axis_z'])

            total_max = max_x_mean + max_y_mean + max_z_mean
            total_mean = mean_x_mean + mean_y_mean + mean_z_mean

            for axis_name, max_val, mean_val in zip(['X', 'Y', 'Z'],
                                                    [max_x_mean, max_y_mean, max_z_mean],
                                                    [mean_x_mean, mean_y_mean, mean_z_mean]):
                max_contribution = (max_val / total_max * 100) if total_max > 0 else 0
                mean_contribution = (mean_val / total_mean * 100) if total_mean > 0 else 0
                writer.writerow([axis_name, f"{max_val:.6f}", f"{mean_val:.6f}",
                                 f"{max_contribution:.1f}% / {mean_contribution:.1f}%"])

            writer.writerow([])  # Пустая строка

            # Раздел: Данные по каждой частице
            writer.writerow(["ДАННЫЕ ПО КАЖДОЙ ЧАСТИЦЕ"])
            headers = [
                "ID частицы",
                "Медиана X", "Медиана Y", "Медиана Z",
                "Параметр t", "Стд. t",
                "Макс. откл. от оси", "Ср. откл. от оси", "Стд. откл. от оси",
                "Макс. X от оси", "Макс. Y от оси", "Макс. Z от оси",
                "Ср. X от оси", "Ср. Y от оси", "Ср. Z от оси",
                "Расст. медианы до оси", "Относ. откл. (%)"
            ]

            writer.writerow(headers)

            # Рассчитываем относительные отклонения (в процентах от среднего)
            mean_all_deviations = np.mean(mean_deviations)

            # Добавляем данные для каждой частицы
            for i in range(n_particles):
                # Относительное отклонение (в % от среднего)
                relative_deviation = (mean_deviations[i] / mean_all_deviations * 100) if mean_all_deviations > 0 else 0

                row = [
                    i,  # ID частицы
                    f"{results['median_positions'][i, 0]:.6f}",  # Медиана X
                    f"{results['median_positions'][i, 1]:.6f}",  # Медиана Y
                    f"{results['median_positions'][i, 2]:.6f}",  # Медиана Z
                    f"{axis_deviations_results['mean_projections'][i]:.6f}",  # Параметр t (средний)
                    f"{axis_deviations_results['std_projections'][i]:.6f}",  # Стандартное отклонение t
                    f"{max_deviations[i]:.6f}",  # Макс. отклонение от оси
                    f"{mean_deviations[i]:.6f}",  # Ср. отклонение от оси
                    f"{axis_deviations_results['std_axis_deviations'][i]:.6f}",  # Стд. отклонение от оси
                    f"{axis_deviations_results['max_axis_x'][i]:.6f}",  # Макс. X от оси
                    f"{axis_deviations_results['max_axis_y'][i]:.6f}",  # Макс. Y от оси
                    f"{axis_deviations_results['max_axis_z'][i]:.6f}",  # Макс. Z от оси
                    f"{axis_deviations_results['mean_axis_x'][i]:.6f}",  # Ср. X от оси
                    f"{axis_deviations_results['mean_axis_y'][i]:.6f}",  # Ср. Y от оси
                    f"{axis_deviations_results['mean_axis_z'][i]:.6f}",  # Ср. Z от оси
                    f"{axis_results['distances_to_axis'][i]:.6f}",  # Расстояние медианы до оси
                    f"{relative_deviation:.2f}"  # Относительное отклонение (%)
                ]

                writer.writerow(row)

            # Раздел: Топ-10 частиц с наибольшими отклонениями от оси
            writer.writerow([])  # Пустая строка
            writer.writerow(["ТОП-10 ЧАСТИЦ С НАИБОЛЬШИМИ ОТКЛОНЕНИЯМИ ОТ ОСИ"])
            writer.writerow(["Ранг", "ID частицы", "Макс. откл. от оси", "Ср. откл. от оси",
                             "Медиана X", "Медиана Y", "Медиана Z", "Параметр t"])

            # Находим индексы топ-10 частиц по максимальным отклонениям от оси
            top10_indices = np.argsort(max_deviations)[-10:][::-1]

            for rank, idx in enumerate(top10_indices, 1):
                writer.writerow([
                    rank,
                    idx,
                    f"{max_deviations[idx]:.6f}",
                    f"{mean_deviations[idx]:.6f}",
                    f"{results['median_positions'][idx, 0]:.6f}",
                    f"{results['median_positions'][idx, 1]:.6f}",
                    f"{results['median_positions'][idx, 2]:.6f}",
                    f"{axis_deviations_results['mean_projections'][idx]:.6f}"
                ])

        print(f"CSV файл с отклонениями от оси сохранен: {full_path}")
        print(f"Количество записей: {n_particles} частиц")

        # Создаем также простую версию CSV с помощью pandas
        print("\nСоздание упрощенной версии CSV...")

        # Создаем DataFrame для простой версии
        simple_data = []
        for i in range(n_particles):
            simple_data.append({
                'Particle_ID': i,
                'Median_X': results['median_positions'][i, 0],
                'Median_Y': results['median_positions'][i, 1],
                'Median_Z': results['median_positions'][i, 2],
                'Mean_Projection_t': axis_deviations_results['mean_projections'][i],
                'Max_Deviation_From_Axis': max_deviations[i],
                'Mean_Deviation_From_Axis': mean_deviations[i],
                'Std_Deviation_From_Axis': axis_deviations_results['std_axis_deviations'][i],
                'Distance_Median_To_Axis': axis_results['distances_to_axis'][i],
                'Max_X_Deviation': axis_deviations_results['max_axis_x'][i],
                'Max_Y_Deviation': axis_deviations_results['max_axis_y'][i],
                'Max_Z_Deviation': axis_deviations_results['max_axis_z'][i]
            })

        simple_df = pd.DataFrame(simple_data)
        simple_csv_path = os.path.join(output_path, "axis_deviations_simple.csv")
        simple_df.to_csv(simple_csv_path, index=False, float_format='%.6f', encoding='utf-8-sig')

        print(f"Упрощенный CSV файл сохранен: {simple_csv_path}")

        # Создаем файл со сводной статистикой
        stats_data = {
            'Statistic': [
                'Total Particles',
                'Mean Max Deviation From Axis',
                'Max Deviation From Axis',
                'Min Max Deviation From Axis',
                'Mean Mean Deviation From Axis',
                'Std of Max Deviations',
                'Axis R²',
                'Mean Distance to Axis',
                'Max Distance to Axis'
            ],
            'Value': [
                n_particles,
                f"{np.mean(max_deviations):.6f}",
                f"{np.max(max_deviations):.6f}",
                f"{np.min(max_deviations):.6f}",
                f"{np.mean(mean_deviations):.6f}",
                f"{np.std(max_deviations):.6f}",
                f"{axis_results['r_squared']:.6f}",
                f"{axis_results['mean_distance']:.6f}",
                f"{axis_results['max_distance']:.6f}"
            ]
        }

        stats_df = pd.DataFrame(stats_data)
        stats_csv_path = os.path.join(output_path, "axis_statistics_summary.csv")
        stats_df.to_csv(stats_csv_path, index=False, encoding='utf-8-sig')

        print(f"Файл со статистикой сохранен: {stats_csv_path}")

        return full_path, simple_csv_path, stats_csv_path

    except Exception as e:
        print(f"Ошибка при сохранении CSV файла с отклонениями от оси: {e}")
        import traceback
        traceback.print_exc()
        return None, None, None


def plot_axis_deviations(axis_deviations_results, output_path, filename_prefix="axis_deviations"):
    """
    Создает графики для визуализации отклонений от оси.
    """
    if axis_deviations_results is None:
        return []

    try:
        print(f"\nСоздание графиков отклонений от оси...")

        plot_files = []

        max_deviations = axis_deviations_results['max_axis_deviations']
        mean_deviations = axis_deviations_results['mean_axis_deviations']

        # 1. Гистограмма максимальных отклонений от оси
        plt.figure(figsize=(10, 6))
        plt.hist(max_deviations, bins=50, alpha=0.7, color='lightcoral', edgecolor='black')
        plt.xlabel('Максимальное отклонение от оси')
        plt.ylabel('Количество частиц')
        plt.title('Распределение максимальных отклонений частиц от оси')
        plt.grid(True, alpha=0.3)

        mean_max = np.mean(max_deviations)
        median_max = np.median(max_deviations)
        plt.axvline(mean_max, color='red', linestyle='--', label=f'Среднее: {mean_max:.4f}')
        plt.axvline(median_max, color='green', linestyle='--', label=f'Медиана: {median_max:.4f}')
        plt.legend()

        hist_path = os.path.join(output_path, f"{filename_prefix}_histogram.png")
        plt.savefig(hist_path, dpi=150, bbox_inches='tight')
        plot_files.append(hist_path)
        print(f"  Гистограмма сохранена: {hist_path}")

        # 2. График отклонений от оси по частицам
        plt.figure(figsize=(12, 6))
        particle_indices = np.arange(len(max_deviations))

        plt.subplot(1, 2, 1)
        plt.scatter(particle_indices, max_deviations, alpha=0.5, s=10, color='red')
        plt.xlabel('Индекс частицы')
        plt.ylabel('Максимальное отклонение от оси')
        plt.title('Максимальные отклонения от оси по частицам')
        plt.grid(True, alpha=0.3)

        plt.subplot(1, 2, 2)
        plt.scatter(particle_indices, mean_deviations, alpha=0.5, s=10, color='orange')
        plt.xlabel('Индекс частицы')
        plt.ylabel('Среднее отклонение от оси')
        plt.title('Средние отклонения от оси по частицам')
        plt.grid(True, alpha=0.3)

        scatter_path = os.path.join(output_path, f"{filename_prefix}_scatter.png")
        plt.savefig(scatter_path, dpi=150, bbox_inches='tight')
        plot_files.append(scatter_path)
        print(f"  Точечные графики сохранены: {scatter_path}")

        # 3. График отклонений от оси по координатам
        plt.figure(figsize=(12, 8))

        plt.subplot(2, 2, 1)
        plt.scatter(particle_indices, axis_deviations_results['max_axis_x'],
                    alpha=0.5, s=10, color='r', label='X')
        plt.scatter(particle_indices, axis_deviations_results['max_axis_y'],
                    alpha=0.5, s=10, color='g', label='Y')
        plt.scatter(particle_indices, axis_deviations_results['max_axis_z'],
                    alpha=0.5, s=10, color='b', label='Z')
        plt.xlabel('Индекс частицы')
        plt.ylabel('Максимальное отклонение')
        plt.title('Максимальные отклонения от оси по координатам')
        plt.legend()
        plt.grid(True, alpha=0.3)

        plt.subplot(2, 2, 2)
        plt.scatter(particle_indices, axis_deviations_results['mean_axis_x'],
                    alpha=0.5, s=10, color='r', label='X')
        plt.scatter(particle_indices, axis_deviations_results['mean_axis_y'],
                    alpha=0.5, s=10, color='g', label='Y')
        plt.scatter(particle_indices, axis_deviations_results['mean_axis_z'],
                    alpha=0.5, s=10, color='b', label='Z')
        plt.xlabel('Индекс частицы')
        plt.ylabel('Среднее отклонение')
        plt.title('Средние отклонения от оси по координатам')
        plt.legend()
        plt.grid(True, alpha=0.3)

        plt.subplot(2, 2, 3)
        components = ['X', 'Y', 'Z']
        max_values = [np.mean(axis_deviations_results['max_axis_x']),
                      np.mean(axis_deviations_results['max_axis_y']),
                      np.mean(axis_deviations_results['max_axis_z'])]
        plt.bar(components, max_values, color=['red', 'green', 'blue'], alpha=0.7)
        plt.ylabel('Среднее максимальное отклонение')
        plt.title('Средние максимальные отклонения от оси по осям')

        plt.subplot(2, 2, 4)
        mean_values = [np.mean(axis_deviations_results['mean_axis_x']),
                       np.mean(axis_deviations_results['mean_axis_y']),
                       np.mean(axis_deviations_results['mean_axis_z'])]
        plt.bar(components, mean_values, color=['red', 'green', 'blue'], alpha=0.7)
        plt.ylabel('Среднее отклонение')
        plt.title('Средние отклонения от оси по осям')

        plt.tight_layout()
        coords_path = os.path.join(output_path, f"{filename_prefix}_coordinates.png")
        plt.savefig(coords_path, dpi=150, bbox_inches='tight')
        plot_files.append(coords_path)
        print(f"  Графики по координатам сохранены: {coords_path}")

        # 4. График зависимости отклонений от положения вдоль оси
        plt.figure(figsize=(10, 6))

        projections = axis_deviations_results['mean_projections']

        plt.subplot(1, 2, 1)
        plt.scatter(projections, max_deviations, alpha=0.5, s=10, color='red')
        plt.xlabel('Параметр t (положение вдоль оси)')
        plt.ylabel('Максимальное отклонение от оси')
        plt.title('Зависимость отклонений от положения вдоль оси')
        plt.grid(True, alpha=0.3)

        # Линейная регрессия для тренда
        if len(projections) > 1:
            slope, intercept, r_value, p_value, std_err = stats.linregress(projections, max_deviations)
            x_fit = np.array([np.min(projections), np.max(projections)])
            y_fit = slope * x_fit + intercept
            plt.plot(x_fit, y_fit, 'r--', alpha=0.7,
                     label=f'Тренд: R²={r_value ** 2:.3f}')
            plt.legend()

        plt.subplot(1, 2, 2)
        plt.scatter(projections, mean_deviations, alpha=0.5, s=10, color='orange')
        plt.xlabel('Параметр t (положение вдоль оси)')
        plt.ylabel('Среднее отклонение от оси')
        plt.title('Зависимость средних отклонений от положения')
        plt.grid(True, alpha=0.3)

        # Линейная регрессия для тренда
        if len(projections) > 1:
            slope, intercept, r_value, p_value, std_err = stats.linregress(projections, mean_deviations)
            x_fit = np.array([np.min(projections), np.max(projections)])
            y_fit = slope * x_fit + intercept
            plt.plot(x_fit, y_fit, 'r--', alpha=0.7,
                     label=f'Тренд: R²={r_value ** 2:.3f}')
            plt.legend()

        plt.tight_layout()
        trend_path = os.path.join(output_path, f"{filename_prefix}_trend.png")
        plt.savefig(trend_path, dpi=150, bbox_inches='tight')
        plot_files.append(trend_path)
        print(f"  Графики трендов сохранены: {trend_path}")

        plt.close('all')

        return plot_files

    except Exception as e:
        print(f"Ошибка при создании графиков отклонений от оси: {e}")
        return []


def plot_axis_3d(median_positions, axis_results, output_path, filename="axis_3d_plot.png"):
    """
    Строит 3D график медианных положений частиц и оси структуры.
    """
    try:
        print(f"\nСоздание 3D графика оси структуры...")

        fig = plt.figure(figsize=(14, 10))
        ax = fig.add_subplot(111, projection='3d')

        # 1. Рисуем медианные положения частиц
        scatter = ax.scatter(median_positions[:, 0],
                             median_positions[:, 1],
                             median_positions[:, 2],
                             c='blue', alpha=0.6, s=50,
                             label='Медианные положения частиц')

        # 2. Рисуем ось структуры
        line_points = axis_results['line_points']
        ax.plot(line_points[:, 0], line_points[:, 1], line_points[:, 2],
                color='red', linewidth=3, label='Ось структуры')

        # 3. Рисуем центр масс
        centroid = axis_results['centroid']
        ax.scatter(centroid[0], centroid[1], centroid[2],
                   color='green', s=200, marker='*',
                   label='Центр масс', edgecolors='black')

        # 4. Рисуем направляющий вектор
        direction = axis_results['direction']
        scale = np.ptp(median_positions, axis=0).max() * 0.5
        vector_end = centroid + direction * scale
        ax.quiver(centroid[0], centroid[1], centroid[2],
                  direction[0], direction[1], direction[2],
                  color='orange', length=scale, arrow_length_ratio=0.1,
                  linewidth=2, label='Направление оси')

        # Настройки графика
        ax.set_xlabel('X', fontsize=12)
        ax.set_ylabel('Y', fontsize=12)
        ax.set_zlabel('Z', fontsize=12)
        ax.set_title('Медианные положения частиц и ось структуры', fontsize=14, pad=20)

        # Добавляем информацию об уравнении прямой
        equation_text = f"Ось: (x-{centroid[0]:.2f})/{direction[0]:.2f} = " \
                        f"(y-{centroid[1]:.2f})/{direction[1]:.2f} = " \
                        f"(z-{centroid[2]:.2f})/{direction[2]:.2f}\n" \
                        f"R² = {axis_results['r_squared']:.4f}"

        ax.text2D(0.05, 0.95, equation_text, transform=ax.transAxes,
                  fontsize=10, verticalalignment='top',
                  bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))

        ax.legend(loc='upper right', fontsize=10)

        # Устанавливаем одинаковый масштаб по осям
        max_range = np.array([median_positions[:, 0].max() - median_positions[:, 0].min(),
                              median_positions[:, 1].max() - median_positions[:, 1].min(),
                              median_positions[:, 2].max() - median_positions[:, 2].min()]).max() / 2.0

        mid_x = (median_positions[:, 0].max() + median_positions[:, 0].min()) * 0.5
        mid_y = (median_positions[:, 1].max() + median_positions[:, 1].min()) * 0.5
        mid_z = (median_positions[:, 2].max() + median_positions[:, 2].min()) * 0.5

        ax.set_xlim(mid_x - max_range, mid_x + max_range)
        ax.set_ylim(mid_y - max_range, mid_y + max_range)
        ax.set_zlim(mid_z - max_range, mid_z + max_range)

        # Сохраняем график
        full_path = os.path.join(output_path, filename)
        plt.savefig(full_path, dpi=150, bbox_inches='tight')
        print(f"  3D график оси сохранен: {full_path}")

        plt.close('all')

        return full_path

    except Exception as e:
        print(f"Ошибка при создании 3D графика оси: {e}")
        import traceback
        traceback.print_exc()
        return None


def main():
    """
    Основная функция программы.
    """
    # Укажите путь к папке с файлами
    path = "C:/Users/17.3 Active Systems/Downloads/3Д/3Д"  # ЗАМЕНИТЕ НА ВАШ ПУТЬ!

    print("=" * 70)
    print("АНАЛИЗ КООРДИНАТ ЧАСТИЦ И РАСЧЕТ ОТКЛОНЕНИЙ ОТ ОСИ")
    print("=" * 70)

    # 1. Чтение данных
    x, y, z, coords_3d = read_coordinates_from_path(path)

    if coords_3d is None:
        print("Не удалось загрузить данные. Завершение работы.")
        return

    # 2. Расчет медианных положений и отклонений
    results = calculate_median_deviations(coords_3d)

    if results is None:
        print("Не удалось рассчитать отклонения. Завершение работы.")
        return

    # 3. Расчет оси структуры
    axis_results = calculate_axis_line(results['median_positions'])

    # 4. Расчет отклонений от оси во времени
    axis_deviations_results = calculate_deviations_from_axis(coords_3d, axis_results)

    # 5. Сохранение отклонений от оси в CSV
    axis_csv_files = save_axis_deviations_to_csv(results, axis_results,
                                                 axis_deviations_results, path)

    # 6. Построение графиков отклонений от оси
    axis_deviations_plots = plot_axis_deviations(axis_deviations_results, path)

    # 7. Построение 3D графика оси
    axis_3d_plot = plot_axis_3d(results['median_positions'], axis_results, path)

    print("\n" + "=" * 70)
    print("АНАЛИЗ ЗАВЕРШЕН УСПЕШНО!")
    print("=" * 70)

    # Сводка созданных файлов
    print("\nСОЗДАННЫЕ ФАЙЛЫ ОТКЛОНЕНИЙ ОТ ОСИ:")

    if axis_csv_files:
        print(f"• Подробный CSV файл: {os.path.basename(axis_csv_files[0])}")
        print(f"• Упрощенный CSV файл: {os.path.basename(axis_csv_files[1])}")
        print(f"• Статистика CSV файл: {os.path.basename(axis_csv_files[2])}")

    if axis_deviations_plots:
        print(f"• Графики отклонений от оси ({len(axis_deviations_plots)} файлов):")
        for plot_file in axis_deviations_plots:
            print(f"  - {os.path.basename(plot_file)}")

    if axis_3d_plot:
        print(f"• 3D график оси: {os.path.basename(axis_3d_plot)}")

    # Краткая статистика
    print("\nКРАТКАЯ СТАТИСТИКА ОТКЛОНЕНИЙ ОТ ОСИ:")
    print(f"• Проанализировано частиц: {len(results['particle_indices'])}")

    if axis_deviations_results:
        max_deviations = axis_deviations_results['max_axis_deviations']
        mean_deviations = axis_deviations_results['mean_axis_deviations']

        print(f"• Среднее максимальное отклонение от оси: {np.mean(max_deviations):.4f}")
        print(f"• Максимальное отклонение от оси: {np.max(max_deviations):.4f}")
        print(f"• Среднее среднее отклонение от оси: {np.mean(mean_deviations):.4f}")

    if axis_results:
        print(f"• Качество аппроксимации оси R²: {axis_results['r_squared']:.4f}")


if __name__ == "__main__":
    # Укажите путь к вашей папке
    path = "C:/Users/17.3 Active Systems/Downloads/3Д/3Д"  # ЗАМЕНИТЕ НА ВАШ ПУТЬ!

    # Проверяем существование папки
    if not os.path.exists(path):
        print(f"Папка {path} не существует!")

        # Создаем тестовые данные с явной линейной структурой
        n_timesteps = 50
        n_particles = 30

        np.random.seed(42)

        # Создаем линейную структуру вдоль оси
        t = np.linspace(-5, 5, n_particles)

        centroid = np.array([1.0, 2.0, 3.0])
        direction = np.array([0.5, 0.3, 0.8])
        direction = direction / np.linalg.norm(direction)

        base_positions = np.array([centroid + ti * direction for ti in t])

        # Добавляем шум
        noise_level = 0.3
        x_data = np.zeros((n_timesteps, n_particles))
        y_data = np.zeros((n_timesteps, n_particles))
        z_data = np.zeros((n_timesteps, n_particles))

        for i in range(n_particles):
            for j in range(n_timesteps):
                noise = np.random.randn(3) * noise_level
                time_variation = np.sin(j * 0.1) * 0.2
                point = base_positions[i] + noise + direction * time_variation
                x_data[j, i] = point[0]
                y_data[j, i] = point[1]
                z_data[j, i] = point[2]

        os.makedirs(path, exist_ok=True)
        np.savetxt(os.path.join(path, 'X1000.txt'), x_data)
        np.savetxt(os.path.join(path, 'Y1000.txt'), y_data)
        np.savetxt(os.path.join(path, 'Z1000.txt'), z_data)

        print(f"Тестовые файлы с линейной структурой созданы в {path}")

    # Полный анализ
    main()
