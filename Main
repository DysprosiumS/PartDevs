import numpy as np
import os
import pandas as pd
import matplotlib.pyplot as plt
import csv


def read_coordinates_from_path(path, filenames=None, delimiter=None):
    """
    Считывает координаты частиц из файлов в указанной папке.
    """
    if filenames is None:
        filenames = ['X1000.txt', 'Y1000.txt', 'Z1000.txt']

    try:
        if not os.path.exists(path):
            raise FileNotFoundError(f"Папка {path} не существует")

        filepaths = [os.path.join(path, fname) for fname in filenames]

        print(f"Чтение файлов из папки: {path}")

        for fpath, fname in zip(filepaths, filenames):
            if not os.path.exists(fpath):
                raise FileNotFoundError(f"Файл {fname} не найден в папке {path}")

        if delimiter:
            x_data = np.loadtxt(filepaths[0], delimiter=delimiter)
            y_data = np.loadtxt(filepaths[1], delimiter=delimiter)
            z_data = np.loadtxt(filepaths[2], delimiter=delimiter)
        else:
            x_data = np.loadtxt(filepaths[0])
            y_data = np.loadtxt(filepaths[1])
            z_data = np.loadtxt(filepaths[2])

        print(f"\nРазмеры файлов:")
        print(f"  {filenames[0]}: {x_data.shape} (временные шаги={x_data.shape[0]}, частицы={x_data.shape[1]})")
        print(f"  {filenames[1]}: {y_data.shape}")
        print(f"  {filenames[2]}: {z_data.shape}")

        if not (x_data.shape == y_data.shape == z_data.shape):
            print("\nПредупреждение: Размеры файлов не совпадают!")
            min_rows = min(x_data.shape[0], y_data.shape[0], z_data.shape[0])
            min_cols = min(x_data.shape[1], y_data.shape[1], z_data.shape[1])

            x_data = x_data[:min_rows, :min_cols]
            y_data = y_data[:min_rows, :min_cols]
            z_data = z_data[:min_rows, :min_cols]
            print(f"Используется общий размер: {x_data.shape}")

        coordinates_3d = np.zeros((x_data.shape[0], x_data.shape[1], 3))
        coordinates_3d[:, :, 0] = x_data
        coordinates_3d[:, :, 1] = y_data
        coordinates_3d[:, :, 2] = z_data

        print(f"\nСоздан 3D массив координат: {coordinates_3d.shape}")
        print(f"  Временных шагов: {coordinates_3d.shape[0]}")
        print(f"  Частиц: {coordinates_3d.shape[1]}")

        return x_data, y_data, z_data, coordinates_3d

    except Exception as e:
        print(f"Ошибка: {e}")
        return None, None, None, None


def calculate_median_deviations(coordinates_3d):
    """
    Рассчитывает для каждой частицы медианное положение, отклонения от него,
    максимальное и среднее отклонение.
    """
    if coordinates_3d is None:
        print("Ошибка: Нет данных для расчета")
        return None

    print("\n" + "=" * 60)
    print("РАСЧЕТ МЕДИАННЫХ ПОЛОЖЕНИЙ И ОТКЛОНЕНИЙ")
    print("=" * 60)

    n_particles = coordinates_3d.shape[1]
    n_timesteps = coordinates_3d.shape[0]

    # 1. Рассчитываем медианное положение для каждой частицы
    print(f"Расчет медианных положений для {n_particles} частиц...")

    median_positions = np.median(coordinates_3d, axis=0)  # Форма: [частицы, 3]

    # 2. Рассчитываем отклонения от медианного положения
    print(f"Расчет отклонений для {n_timesteps} временных шагов...")

    deviations = np.zeros_like(coordinates_3d)

    for particle_idx in range(n_particles):
        deviations[:, particle_idx, :] = coordinates_3d[:, particle_idx, :] - median_positions[particle_idx, :]

    # 3. Рассчитываем расстояния (евклидовы нормы) отклонений
    print(f"Расчет расстояний отклонений...")

    deviation_distances = np.linalg.norm(deviations, axis=2)  # Форма: [время, частицы]

    # 4. Рассчитываем статистики для каждой частицы
    max_deviations = np.max(deviation_distances, axis=0)
    mean_deviations = np.mean(deviation_distances, axis=0)

    # Для каждой координаты отдельно
    max_x_deviations = np.max(np.abs(deviations[:, :, 0]), axis=0)
    max_y_deviations = np.max(np.abs(deviations[:, :, 1]), axis=0)
    max_z_deviations = np.max(np.abs(deviations[:, :, 2]), axis=0)

    mean_x_deviations = np.mean(np.abs(deviations[:, :, 0]), axis=0)
    mean_y_deviations = np.mean(np.abs(deviations[:, :, 1]), axis=0)
    mean_z_deviations = np.mean(np.abs(deviations[:, :, 2]), axis=0)

    # Собираем все результаты
    results = {
        'median_positions': median_positions,
        'deviations': deviations,
        'deviation_distances': deviation_distances,
        'max_deviations': max_deviations,
        'mean_deviations': mean_deviations,
        'max_x_deviations': max_x_deviations,
        'max_y_deviations': max_y_deviations,
        'max_z_deviations': max_z_deviations,
        'mean_x_deviations': mean_x_deviations,
        'mean_y_deviations': mean_y_deviations,
        'mean_z_deviations': mean_z_deviations,
        'particle_indices': np.arange(n_particles)
    }

    return results


def plot_deviations(results, output_path, filename_prefix="deviations"):
    """
    Создает графики для визуализации отклонений.
    """
    if results is None:
        return []

    try:
        print(f"\nСоздание графиков...")

        # 1. Гистограмма максимальных отклонений
        plt.figure(figsize=(10, 6))
        plt.hist(results['max_deviations'], bins=50, alpha=0.7, color='skyblue', edgecolor='black')
        plt.xlabel('Максимальное отклонение')
        plt.ylabel('Количество частиц')
        plt.title('Распределение максимальных отклонений частиц')
        plt.grid(True, alpha=0.3)

        # Добавляем вертикальные линии для статистики
        mean_max = np.mean(results['max_deviations'])
        median_max = np.median(results['max_deviations'])
        plt.axvline(mean_max, color='red', linestyle='--', label=f'Среднее: {mean_max:.4f}')
        plt.axvline(median_max, color='green', linestyle='--', label=f'Медиана: {median_max:.4f}')
        plt.legend()

        hist_path = os.path.join(output_path, f"{filename_prefix}_histogram.png")
        plt.savefig(hist_path, dpi=150, bbox_inches='tight')
        print(f"  Гистограмма сохранена: {hist_path}")

        # 2. График максимальных отклонений по частицам
        plt.figure(figsize=(12, 6))
        particle_indices = results['particle_indices']

        plt.subplot(1, 2, 1)
        plt.scatter(particle_indices, results['max_deviations'], alpha=0.5, s=10)
        plt.xlabel('Индекс частицы')
        plt.ylabel('Максимальное отклонение')
        plt.title('Максимальные отклонения по частицам')
        plt.grid(True, alpha=0.3)

        plt.subplot(1, 2, 2)
        plt.scatter(particle_indices, results['mean_deviations'], alpha=0.5, s=10, color='orange')
        plt.xlabel('Индекс частицы')
        plt.ylabel('Среднее отклонение')
        plt.title('Средние отклонения по частицам')
        plt.grid(True, alpha=0.3)

        scatter_path = os.path.join(output_path, f"{filename_prefix}_scatter.png")
        plt.savefig(scatter_path, dpi=150, bbox_inches='tight')
        print(f"  Точечные графики сохранены: {scatter_path}")

        # 3. График отклонений по координатам
        plt.figure(figsize=(12, 8))

        plt.subplot(2, 2, 1)
        plt.scatter(particle_indices, results['max_x_deviations'], alpha=0.5, s=10, color='r', label='X')
        plt.scatter(particle_indices, results['max_y_deviations'], alpha=0.5, s=10, color='g', label='Y')
        plt.scatter(particle_indices, results['max_z_deviations'], alpha=0.5, s=10, color='b', label='Z')
        plt.xlabel('Индекс частицы')
        plt.ylabel('Максимальное отклонение')
        plt.title('Максимальные отклонения по координатам')
        plt.legend()
        plt.grid(True, alpha=0.3)

        plt.subplot(2, 2, 2)
        plt.scatter(particle_indices, results['mean_x_deviations'], alpha=0.5, s=10, color='r', label='X')
        plt.scatter(particle_indices, results['mean_y_deviations'], alpha=0.5, s=10, color='g', label='Y')
        plt.scatter(particle_indices, results['mean_z_deviations'], alpha=0.5, s=10, color='b', label='Z')
        plt.xlabel('Индекс частицы')
        plt.ylabel('Среднее отклонение')
        plt.title('Средние отклонения по координатам')
        plt.legend()
        plt.grid(True, alpha=0.3)

        plt.subplot(2, 2, 3)
        components = ['X', 'Y', 'Z']
        max_values = [np.mean(results['max_x_deviations']),
                      np.mean(results['max_y_deviations']),
                      np.mean(results['max_z_deviations'])]
        plt.bar(components, max_values, color=['red', 'green', 'blue'], alpha=0.7)
        plt.ylabel('Среднее максимальное отклонение')
        plt.title('Средние максимальные отклонения по осям')

        plt.subplot(2, 2, 4)
        mean_values = [np.mean(results['mean_x_deviations']),
                       np.mean(results['mean_y_deviations']),
                       np.mean(results['mean_z_deviations'])]
        plt.bar(components, mean_values, color=['red', 'green', 'blue'], alpha=0.7)
        plt.ylabel('Среднее отклонение')
        plt.title('Средние отклонения по осям')

        plt.tight_layout()
        coords_path = os.path.join(output_path, f"{filename_prefix}_coordinates.png")
        plt.savefig(coords_path, dpi=150, bbox_inches='tight')
        print(f"  Графики по координатам сохранены: {coords_path}")

        # 4. Дополнительный график: сравнение максимальных и средних отклонений
        plt.figure(figsize=(10, 6))

        # Сортируем частицы по максимальному отклонению для красивого графика
        sorted_indices = np.argsort(results['max_deviations'])
        sorted_max = results['max_deviations'][sorted_indices]
        sorted_mean = results['mean_deviations'][sorted_indices]

        plt.plot(sorted_max, label='Максимальные отклонения', linewidth=2)
        plt.plot(sorted_mean, label='Средние отклонения', linewidth=2)
        plt.xlabel('Частицы (отсортированы по макс. отклонению)')
        plt.ylabel('Отклонение')
        plt.title('Сравнение максимальных и средних отклонений')
        plt.legend()
        plt.grid(True, alpha=0.3)

        comparison_path = os.path.join(output_path, f"{filename_prefix}_comparison.png")
        plt.savefig(comparison_path, dpi=150, bbox_inches='tight')
        print(f"  График сравнения сохранен: {comparison_path}")

        plt.close('all')

        return [hist_path, scatter_path, coords_path, comparison_path]

    except Exception as e:
        print(f"Ошибка при создании графиков: {e}")
        return []


def save_results_to_csv(results, output_path, filename="particle_deviations.csv"):
    """
    Сохраняет результаты расчетов в один CSV файл с правильной обработкой текста.
    """
    if results is None:
        print("Нет данных для сохранения")
        return None, None, None

    try:
        print(f"\n" + "=" * 60)
        print(f"СОХРАНЕНИЕ РЕЗУЛЬТАТОВ В CSV ФАЙЛ")
        print("=" * 60)

        n_particles = len(results['particle_indices'])

        # Создаем полный путь
        full_path = os.path.join(output_path, filename)

        # Открываем файл с правильными параметрами
        with open(full_path, 'w', newline='', encoding='utf-8-sig') as f:
            writer = csv.writer(f)

            # Заголовок файла
            writer.writerow(["АНАЛИЗ ОТКЛОНЕНИЙ ЧАСТИЦ ОТ МЕДИАННОГО ПОЛОЖЕНИЯ"])
            writer.writerow([f"Дата анализа: {pd.Timestamp.now().strftime('%Y-%m-%d %H:%M:%S')}"])
            writer.writerow([f"Количество частиц: {n_particles}"])
            writer.writerow([])  # Пустая строка

            # Раздел 1: Статистика по всем частицам
            writer.writerow(["ОБЩАЯ СТАТИСТИКА"])
            writer.writerow(["Параметр", "Значение", "Примечание"])
            writer.writerow(
                ["Среднее максимальное отклонение", f"{np.mean(results['max_deviations']):.6f}", "По всем частицам"])
            writer.writerow(
                ["Максимальное отклонение", f"{np.max(results['max_deviations']):.6f}", "Наибольшее значение"])
            writer.writerow(
                ["Минимальное отклонение", f"{np.min(results['max_deviations']):.6f}", "Наименьшее значение"])
            writer.writerow(
                ["Среднее среднее отклонение", f"{np.mean(results['mean_deviations']):.6f}", "По всем частицам"])
            writer.writerow(
                ["Среднее по X", f"{np.mean(results['max_x_deviations']):.6f}", "Макс. отклонения по оси X"])
            writer.writerow(
                ["Среднее по Y", f"{np.mean(results['max_y_deviations']):.6f}", "Макс. отклонения по оси Y"])
            writer.writerow(
                ["Среднее по Z", f"{np.mean(results['max_z_deviations']):.6f}", "Макс. отклонения по оси Z"])
            writer.writerow([])  # Пустая строка

            # Раздел 2: Топ-10 частиц с наибольшими отклонениями
            writer.writerow(["ТОП-10 ЧАСТИЦ С НАИБОЛЬШИМИ ОТКЛОНЕНИЯМИ"])
            writer.writerow(
                ["Ранг", "ID частицы", "Макс. отклонение", "Ср. отклонение", "Медиана X", "Медиана Y", "Медиана Z"])

            # Находим индексы топ-10 частиц по максимальным отклонениям
            top10_indices = np.argsort(results['max_deviations'])[-10:][::-1]

            for rank, idx in enumerate(top10_indices, 1):
                writer.writerow([
                    rank,
                    idx,
                    f"{results['max_deviations'][idx]:.6f}",
                    f"{results['mean_deviations'][idx]:.6f}",
                    f"{results['median_positions'][idx, 0]:.6f}",
                    f"{results['median_positions'][idx, 1]:.6f}",
                    f"{results['median_positions'][idx, 2]:.6f}"
                ])

            writer.writerow([])  # Пустая строка

            # Раздел 3: Полная таблица данных по всем частицам
            writer.writerow(["ПОЛНЫЕ ДАННЫЕ ПО ВСЕМ ЧАСТИЦАМ"])
            writer.writerow(["ID", "Медиана X", "Медиана Y", "Медиана Z",
                             "Макс. откл.", "Ср. откл.",
                             "Макс. X", "Макс. Y", "Макс. Z",
                             "Ср. X", "Ср. Y", "Ср. Z"])

            # Добавляем данные для каждой частицы
            for i in range(n_particles):
                writer.writerow([
                    i,
                    f"{results['median_positions'][i, 0]:.6f}",
                    f"{results['median_positions'][i, 1]:.6f}",
                    f"{results['median_positions'][i, 2]:.6f}",
                    f"{results['max_deviations'][i]:.6f}",
                    f"{results['mean_deviations'][i]:.6f}",
                    f"{results['max_x_deviations'][i]:.6f}",
                    f"{results['max_y_deviations'][i]:.6f}",
                    f"{results['max_z_deviations'][i]:.6f}",
                    f"{results['mean_x_deviations'][i]:.6f}",
                    f"{results['mean_y_deviations'][i]:.6f}",
                    f"{results['mean_z_deviations'][i]:.6f}"
                ])

        print(f"CSV файл сохранен: {full_path}")

        # Проверяем и показываем содержимое файла
        print("\nПРОВЕРКА СОХРАНЕННОГО ФАЙЛА:")
        print("-" * 80)

        with open(full_path, 'r', encoding='utf-8-sig') as f:
            lines = f.readlines()
            print(f"Всего строк в файле: {len(lines)}")
            print("\nПервые 20 строк файла:")
            for i, line in enumerate(lines[:20]):
                print(f"{i + 1:3d}: {line.strip()}")

        print("-" * 80)

        # Альтернативный вариант: использование pandas для создания CSV
        print("\nАЛЬТЕРНАТИВНЫЙ ВАРИАНТ (используя pandas):")

        # Создаем DataFrame для основной таблицы данных
        data_for_df = []
        for i in range(n_particles):
            data_for_df.append({
                'ID': i,
                'Median_X': results['median_positions'][i, 0],
                'Median_Y': results['median_positions'][i, 1],
                'Median_Z': results['median_positions'][i, 2],
                'Max_Deviation': results['max_deviations'][i],
                'Mean_Deviation': results['mean_deviations'][i],
                'Max_X': results['max_x_deviations'][i],
                'Max_Y': results['max_y_deviations'][i],
                'Max_Z': results['max_z_deviations'][i],
                'Mean_X': results['mean_x_deviations'][i],
                'Mean_Y': results['mean_y_deviations'][i],
                'Mean_Z': results['mean_z_deviations'][i]
            })

        df = pd.DataFrame(data_for_df)

        # Сохраняем DataFrame в CSV
        pandas_csv_path = os.path.join(output_path, "particle_data_clean.csv")
        df.to_csv(pandas_csv_path, index=False, float_format='%.6f', encoding='utf-8-sig')

        print(f"CSV созданный через pandas: {pandas_csv_path}")
        print(f"Размер таблицы: {df.shape[0]} строк × {df.shape[1]} столбцов")
        print("\nПервые 5 строк таблицы:")
        print(df.head().to_string())

        # Создаем отдельный файл со статистикой
        stats_data = {
            'Parameter': [
                'Total Particles',
                'Mean Max Deviation',
                'Max Deviation',
                'Min Deviation',
                'Mean Mean Deviation',
                'Mean Max X',
                'Mean Max Y',
                'Mean Max Z'
            ],
            'Value': [
                n_particles,
                f"{np.mean(results['max_deviations']):.6f}",
                f"{np.max(results['max_deviations']):.6f}",
                f"{np.min(results['max_deviations']):.6f}",
                f"{np.mean(results['mean_deviations']):.6f}",
                f"{np.mean(results['max_x_deviations']):.6f}",
                f"{np.mean(results['max_y_deviations']):.6f}",
                f"{np.mean(results['max_z_deviations']):.6f}"
            ],
            'Description': [
                'Total number of particles analyzed',
                'Average of maximum deviations across all particles',
                'Largest maximum deviation found',
                'Smallest maximum deviation found',
                'Average of mean deviations across all particles',
                'Average of maximum X deviations',
                'Average of maximum Y deviations',
                'Average of maximum Z deviations'
            ]
        }

        stats_df = pd.DataFrame(stats_data)
        stats_csv_path = os.path.join(output_path, "statistics_summary.csv")
        stats_df.to_csv(stats_csv_path, index=False, encoding='utf-8-sig')

        print(f"\nФайл со статистикой: {stats_csv_path}")

        return full_path, pandas_csv_path, stats_csv_path

    except Exception as e:
        print(f"Ошибка при сохранении CSV файла: {e}")
        import traceback
        traceback.print_exc()
        return None, None, None


def save_simple_csv(results, output_path, filename="particle_results_simple.csv"):
    """
    Сохраняет результаты в простом CSV формате без русских символов.
    """
    try:
        n_particles = len(results['particle_indices'])

        # Создаем DataFrame с английскими заголовками
        data = []
        for i in range(n_particles):
            data.append({
                'Particle_ID': i,
                'Median_X': f"{results['median_positions'][i, 0]:.6f}",
                'Median_Y': f"{results['median_positions'][i, 1]:.6f}",
                'Median_Z': f"{results['median_positions'][i, 2]:.6f}",
                'Max_Deviation': f"{results['max_deviations'][i]:.6f}",
                'Mean_Deviation': f"{results['mean_deviations'][i]:.6f}",
                'Max_X_Dev': f"{results['max_x_deviations'][i]:.6f}",
                'Max_Y_Dev': f"{results['max_y_deviations'][i]:.6f}",
                'Max_Z_Dev': f"{results['max_z_deviations'][i]:.6f}",
                'Mean_X_Dev': f"{results['mean_x_deviations'][i]:.6f}",
                'Mean_Y_Dev': f"{results['mean_y_deviations'][i]:.6f}",
                'Mean_Z_Dev': f"{results['mean_z_deviations'][i]:.6f}"
            })

        df = pd.DataFrame(data)

        # Сохраняем в CSV
        full_path = os.path.join(output_path, filename)
        df.to_csv(full_path, index=False, encoding='utf-8')

        print(f"\nПростой CSV файл сохранен: {full_path}")
        print("Структура файла:")
        print(f"Количество строк: {len(df)}")
        print(f"Количество столбцов: {len(df.columns)}")
        print("\nЗаголовки столбцов:")
        for i, col in enumerate(df.columns, 1):
            print(f"{i:2d}. {col}")

        return full_path

    except Exception as e:
        print(f"Ошибка при сохранении простого CSV: {e}")
        return None


def save_csv_with_excel_compatibility(results, output_path, filename="particle_results_excel.csv"):
    """
    Сохраняет CSV файл с максимальной совместимостью с Excel.
    """
    try:
        full_path = os.path.join(output_path, filename)

        with open(full_path, 'w', newline='', encoding='utf-8-sig') as f:
            writer = csv.writer(f, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)

            # Записываем заголовки
            headers = [
                "Particle ID", "Median X", "Median Y", "Median Z",
                "Maximum Deviation", "Mean Deviation",
                "Max X Dev", "Max Y Dev", "Max Z Dev",
                "Mean X Dev", "Mean Y Dev", "Mean Z Dev"
            ]
            writer.writerow(headers)

            # Записываем данные
            for i in range(len(results['particle_indices'])):
                row = [
                    i,
                    results['median_positions'][i, 0],
                    results['median_positions'][i, 1],
                    results['median_positions'][i, 2],
                    results['max_deviations'][i],
                    results['mean_deviations'][i],
                    results['max_x_deviations'][i],
                    results['max_y_deviations'][i],
                    results['max_z_deviations'][i],
                    results['mean_x_deviations'][i],
                    results['mean_y_deviations'][i],
                    results['mean_z_deviations'][i]
                ]
                writer.writerow(row)

        print(f"\nCSV файл для Excel сохранен: {full_path}")
        print("Этот файл должен корректно открываться в Microsoft Excel.")

        return full_path

    except Exception as e:
        print(f"Ошибка при сохранении CSV для Excel: {e}")
        return None


def main():
    """
    Основная функция программы.
    """
    # Укажите путь к папке с файлами
    path = "C:/Users/17.3 Active Systems/Downloads/3Д/3Д"  # ЗАМЕНИТЕ НА ВАШ ПУТЬ!

    print("=" * 70)
    print("АНАЛИЗ КООРДИНАТ ЧАСТИЦ")
    print("=" * 70)

    # 1. Чтение данных
    x, y, z, coords_3d = read_coordinates_from_path(path)

    if coords_3d is None:
        print("Не удалось загрузить данные. Завершение работы.")
        return

    # 2. Расчет медианных положений и отклонений
    results = calculate_median_deviations(coords_3d)

    if results is None:
        print("Не удалось рассчитать отклонения. Завершение работы.")
        return

    # 3. Сохранение результатов в разные форматы CSV
    print("\n" + "=" * 70)
    print("СОЗДАНИЕ CSV ФАЙЛОВ")
    print("=" * 70)

    # Вариант 1: Детальный CSV с русским текстом
    csv_file1, csv_file2, csv_file3 = save_results_to_csv(results, path)

    # Вариант 2: Простой CSV с английскими заголовками
    simple_csv = save_simple_csv(results, path)

    # Вариант 3: CSV с совместимостью для Excel
    excel_csv = save_csv_with_excel_compatibility(results, path)

    # 4. Создание графиков
    plot_files = plot_deviations(results, path)

    print("\n" + "=" * 70)
    print("АНАЛИЗ ЗАВЕРШЕН УСПЕШНО!")
    print("=" * 70)

    # Сводка созданных файлов
    print("\nСОЗДАННЫЕ ФАЙЛЫ:")
    files_created = []

    if csv_file1:
        files_created.append(("Детальный CSV (русский текст)", csv_file1))
    if csv_file2:
        files_created.append(("Чистые данные (pandas)", csv_file2))
    if csv_file3:
        files_created.append(("Статистика", csv_file3))
    if simple_csv:
        files_created.append(("Простой CSV", simple_csv))
    if excel_csv:
        files_created.append(("CSV для Excel", excel_csv))

    for i, (desc, filepath) in enumerate(files_created, 1):
        print(f"{i}. {desc}: {os.path.basename(filepath)}")

    if plot_files:
        print(f"\nГрафики (PNG):")
        for i, plot_file in enumerate(plot_files, 1):
            print(f"{i}. {os.path.basename(plot_file)}")

    # Краткая статистика
    print("\nКРАТКАЯ СТАТИСТИКА:")
    print(f"• Проанализировано частиц: {len(results['particle_indices'])}")
    print(f"• Среднее макс. отклонение: {np.mean(results['max_deviations']):.4f}")
    print(f"• Среднее среднее отклонение: {np.mean(results['mean_deviations']):.4f}")

    # Находим частицу с максимальным отклонением
    max_idx = np.argmax(results['max_deviations'])
    print(f"• Частица с наибольшим отклонением: ID={max_idx}, отклонение={results['max_deviations'][max_idx]:.4f}")


def check_csv_encoding(filepath):
    """
    Проверяет кодировку CSV файла.
    """
    try:
        # Пробуем разные кодировки
        encodings = ['utf-8', 'utf-8-sig', 'cp1251', 'iso-8859-1', 'windows-1251']

        for encoding in encodings:
            try:
                with open(filepath, 'r', encoding=encoding) as f:
                    content = f.read(1024)  # Читаем первые 1024 символа
                    print(f"\nПроверка кодировки {encoding}: УСПЕХ")
                    print(f"Первые 100 символов: {content[:100]}")
                    return encoding
            except UnicodeDecodeError:
                print(f"Проверка кодировки {encoding}: ОШИБКА")

        print("\nНе удалось определить кодировку файла.")
        return None

    except Exception as e:
        print(f"Ошибка при проверке кодировки: {e}")
        return None


if __name__ == "__main__":
    # Укажите путь к вашей папке
    path = "C:/Users/17.3 Active Systems/Downloads/3Д/3Д"  # ЗАМЕНИТЕ НА ВАШ ПУТЬ!

    # Проверяем существование папки
    if not os.path.exists(path):
        print(f"Папка {path} не существует!")

        # Создаем тестовые данные
        n_timesteps = 50
        n_particles = 20

        np.random.seed(42)

        x_data = np.zeros((n_timesteps, n_particles))
        y_data = np.zeros((n_timesteps, n_particles))
        z_data = np.zeros((n_timesteps, n_particles))

        for i in range(n_particles):
            amplitude = 0.5 + 1.0 * (i / n_particles)
            x_data[:, i] = np.random.randn(n_timesteps) * amplitude
            y_data[:, i] = np.random.randn(n_timesteps) * amplitude * 0.8
            z_data[:, i] = np.random.randn(n_timesteps) * amplitude * 1.2

        os.makedirs(path, exist_ok=True)
        np.savetxt(os.path.join(path, 'X1000.txt'), x_data)
        np.savetxt(os.path.join(path, 'Y1000.txt'), y_data)
        np.savetxt(os.path.join(path, 'Z1000.txt'), z_data)

        print(f"Тестовые файлы созданы в {path}")

    # Полный анализ
    main()

    # Проверка кодировки файлов (опционально)
    print("\n" + "=" * 70)
    print("ПРОВЕРКА КОДИРОВОК ФАЙЛОВ (опционально)")
    print("=" * 70)

    csv_files = [f for f in os.listdir(path) if f.endswith('.csv')]
    for csv_file in csv_files[:3]:  # Проверяем только первые 3 файла
        print(f"\nПроверка файла: {csv_file}")
        check_csv_encoding(os.path.join(path, csv_file))
